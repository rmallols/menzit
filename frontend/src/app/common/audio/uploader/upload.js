'use strict';
app.directive('audioUpload', ['$q', '$timeout', 'http', 'record', function ($q, $timeout, http, record) {
    return {
        templateUrl: 'audioUpload.html',
        replace: true,
        scope: {
            media: '=ngModel',
            sourceText: '=',
            onSubmitRequest: '='
        },
        link: function (scope) {

            var isNewLocalRecord = false,
                audioOptionCodes = {
                    machine: 0,
                    manual: 1,
                    disabled: 2
                };
            refreshToken();
            initializeDataModel();

            scope.audioOptions = [
                {value: audioOptionCodes.machine, text: 'Generated by a machine'},
                {value: audioOptionCodes.manual, text: 'Generated by you'},
                {value: audioOptionCodes.disabled, text: 'No audio'}
            ];

            scope.selectedAudioOption = scope.media.type || audioOptionCodes.machine;

            scope.startRecording = function () {
                scope.recording = true;
                record.record();
            };

            scope.stopRecording = function () {
                scope.recording = false;
                scope.toBeUpdated = true;
                isNewLocalRecord = true;
                record.get().then(function (recordedAudio) {
                    setRecordedAudio(recordedAudio.base64);
                });
            };

            scope.onSubmitRequest = function () {
                var file = scope.recordedAudio.base64,
                    uploadUrl = '/rest/audio/' + (scope.media._id || ''),
                    deferred = $q.defer();
                if (!file && scope.selectedAudioOption === audioOptionCodes.machine) {
                    processPlayAndSubmit(uploadUrl, file).then(deferred.resolve);
                } else {
                    submit(uploadUrl, file).then(deferred.resolve);
                }
                return deferred.promise;
            };

            scope.onSelectedAudioOptionChange = function (selectedOption) {
                scope.media.type = selectedOption;
                scope.recordedAudio = {};
                scope.toBeDeleted = (selectedOption === 2);
            };

            scope.processAudioBeforePlay = function () {
                var deferred = $q.defer();
                if (scope.selectedAudioOption === audioOptionCodes.machine) {
                    generateAutomaticAudio().then(deferred.resolve);
                } else if (scope.selectedAudioOption === audioOptionCodes.manual && !isNewLocalRecord) {
                    getManualAudio().then(deferred.resolve);
                } else {
                    deferred.resolve();
                }
                return deferred.promise;
            };

            function initializeDataModel() {
                if(!scope.media) {
                    scope.media = {};
                }
                scope.recordedAudio = {};
            }

            function getSubmitHeaders() {
                return {
                    transformRequest: angular.identity,
                    headers: {'Content-Type': undefined}
                };
            }

            function processPlayAndSubmit(uploadUrl, file) {
                var deferred = $q.defer();
                scope.processAudioBeforePlay().then(function () {
                    submit(uploadUrl, file).then(deferred.resolve);
                });
                return deferred.promise;
            }

            function submit(uploadUrl, file) {
                var fileDescriptor = new FormData(),
                    deferred = $q.defer();
                fileDescriptor.append('file', file);
                cUDSubit(uploadUrl, fileDescriptor).then(function (media) {
                    onSubmitSuccess(media, deferred);
                }).catch(function () {
                    onSubmitError(deferred);
                });
                return deferred.promise;
            }

            function cUDSubit(uploadUrl, fileDescriptor) {
                if (!scope.media._id && fileDescriptor && !scope.toBeDeleted) { //The media doesn't exist yet
                    return http.post(uploadUrl, fileDescriptor, getSubmitHeaders());
                } else if (scope.media._id) { //The media already exists
                    return cUDSubitExistingMedia(uploadUrl, fileDescriptor);
                } else { //Nothing has been actually changed
                    return $q.when([scope.media]);
                }
            }

            function cUDSubitExistingMedia(uploadUrl, fileDescriptor) {
                if (scope.toBeDeleted) {
                    delete scope.media._id;
                    return http.delete(uploadUrl);
                } else if (scope.toBeUpdated) {
                    return http.put(uploadUrl, fileDescriptor, getSubmitHeaders());
                } else { //Nothing has been actually changed
                    return $q.when([scope.media]);
                }
            }

            function onSubmitSuccess(media, deferred) {
                refreshToken();
                scope.media._id = (media && media[0]) ? media[0]._id : undefined;
                $timeout(function () { //TODO: issue #9
                    deferred.resolve(media);
                }, 1000);
            }

            function onSubmitError(deferred) {
                deferred.reject();
            }

            function refreshToken() {
                scope.refreshToken = Math.floor(Math.random() * 10000);
            }

            function generateAutomaticAudio() {
                var deferred = $q.defer();
                http.get('/rest/external-audio?q=' + scope.sourceText).then(function (response) {
                    setRecordedAudio(response.data);
                    $timeout(function () {
                        deferred.resolve();
                    }, 0);
                });
                return deferred.promise;
            }

            function getManualAudio() {
                var deferred = $q.defer();
                http.get('/audio/' + scope.media._id).then(function (response) {
                    setRecordedAudio(response.data);
                    $timeout(function () {
                        deferred.resolve();
                    }, 0);
                });
                return deferred.promise;
            }

            function setRecordedAudio(base64Data) {
                scope.recordedAudio.base64 = base64Data;
            }
        }
    };
}]);